--- src/SmartQB.Infrastructure/Services/PdfService.cs
+++ src/SmartQB.Infrastructure/Services/PdfService.cs
@@ -26,80 +26,76 @@
     public Task<byte[]> RenderPageAsync(string filePath, int pageIndex)
         => Task.FromResult(RenderPage(filePath, pageIndex));

-    public Task<List<byte[]>> ExtractQuestionImagesAsync(string filePath, int pageIndex)
+    public List<byte[]> ExtractQuestionImages(string filePath, int pageIndex)
     {
-        return Task.Run(() =>
-        {
-            var results = new List<byte[]>();
+        var results = new List<byte[]>();

-            // 1. Render the full page to SkiaSharp Image
-            using var docReader = DocLib.Instance.GetDocReader(filePath, new PageDimensions());
-            using var pageReader = docReader.GetPageReader(pageIndex);
+        // 1. Render the full page to SkiaSharp Image
+        using var docReader = DocLib.Instance.GetDocReader(filePath, new PageDimensions());
+        using var pageReader = docReader.GetPageReader(pageIndex);

-            var width = pageReader.GetPageWidth();
-            var height = pageReader.GetPageHeight();
-            var rawBytes = pageReader.GetImage(); // BGRA32
+        var width = pageReader.GetPageWidth();
+        var height = pageReader.GetPageHeight();
+        var rawBytes = pageReader.GetImage(); // BGRA32

-            using var data = SKData.CreateCopy(rawBytes);
-            var info = new SKImageInfo(width, height, SKColorType.Bgra8888, SKAlphaType.Premul);
-            using var originalImage = SKImage.FromPixels(info, data);
+        using var data = SKData.CreateCopy(rawBytes);
+        var info = new SKImageInfo(width, height, SKColorType.Bgra8888, SKAlphaType.Premul);
+        using var originalImage = SKImage.FromPixels(info, data);

-            if (originalImage == null)
-                return new List<byte[]>(); // Handle error
+        if (originalImage == null)
+            return new List<byte[]>(); // Handle error

-            using var bitmap = SKBitmap.FromImage(originalImage);
+        using var bitmap = SKBitmap.FromImage(originalImage);

-            // 2. Calculate Horizontal Projection Profile
-            var rowInkDensity = new int[height];
+        // 2. Calculate Horizontal Projection Profile
+        var rowInkDensity = new int[height];

-            // Convert to grayscale for analysis to simplify thresholding
-            for (int y = 0; y < height; y++)
+        // Convert to grayscale for analysis to simplify thresholding
+        for (int y = 0; y < height; y++)
+        {
+            int inkCount = 0;
+            for (int x = 0; x < width; x++)
             {
-                int inkCount = 0;
-                for (int x = 0; x < width; x++)
+                var color = bitmap.GetPixel(x, y);
+                // Simple luminance calculation or just check if not white
+                if (color.Red < 240 || color.Green < 240 || color.Blue < 240)
                 {
-                    var color = bitmap.GetPixel(x, y);
-                    // Simple luminance calculation or just check if not white
-                    if (color.Red < 240 || color.Green < 240 || color.Blue < 240)
-                    {
-                        inkCount++;
-                    }
+                    inkCount++;
                 }
-                rowInkDensity[y] = inkCount;
             }
+            rowInkDensity[y] = inkCount;
+        }

-            // 3. Call the pure logic algorithm
-            var segments = ImageSegmentationLogic.FindVerticalSegments(rowInkDensity, NOISE_THRESHOLD, GAP_THRESHOLD, MIN_QUESTION_HEIGHT).ToList();
+        // 3. Call the pure logic algorithm
+        var segments = ImageSegmentationLogic.FindVerticalSegments(rowInkDensity, NOISE_THRESHOLD, GAP_THRESHOLD, MIN_QUESTION_HEIGHT).ToList();

-            // 4. Crop and Save Images
-            foreach (var segment in segments)
+        // 4. Crop and Save Images
+        foreach (var segment in segments)
+        {
+            int sliceHeight = segment.EndY - segment.StartY;
+
+            // Create subset image
+            using var subset = new SKBitmap(width, sliceHeight);
+
+            using (var canvas = new SKCanvas(subset))
             {
-                int sliceHeight = segment.EndY - segment.StartY;
+                // Draw white background first
+                canvas.Clear(SKColors.White);

-                // Create subset image
-                using var subset = new SKBitmap(width, sliceHeight);
+                var srcRect = new SKRect(0, segment.StartY, width, segment.EndY);
+                var destRect = new SKRect(0, 0, width, sliceHeight);

-                using (var canvas = new SKCanvas(subset))
-                {
-                    // Draw white background first
-                    canvas.Clear(SKColors.White);
+                // Draw original image onto this canvas
+                canvas.DrawBitmap(bitmap, srcRect, destRect);
+            }

-                    var srcRect = new SKRect(0, segment.StartY, width, segment.EndY);
-                    var destRect = new SKRect(0, 0, width, sliceHeight);
+            using var imageSubset = SKImage.FromBitmap(subset);
+            using var dataSubset = imageSubset.Encode(SKEncodedImageFormat.Png, 100);
+            results.Add(dataSubset.ToArray());
+        }

-                    // Draw original image onto this canvas
-                    canvas.DrawBitmap(bitmap, srcRect, destRect);
-                }
-
-                using var imageSubset = SKImage.FromBitmap(subset);
-                using var dataSubset = imageSubset.Encode(SKEncodedImageFormat.Png, 100);
-                results.Add(dataSubset.ToArray());
-            }
-
-            return results;
-        });
+        return results;
     }

     private byte[] RenderPage(string filePath, int pageIndex)
